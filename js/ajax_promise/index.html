<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS 请求</title>
</head>
<body>
    <ul id="repos"></ul>
    <script>
        // 阻塞
        // window.onload有点晚
        document.addEventListener('DOMContentLoaded',async() => {
           // console.log(document.getElementById('repos'));
           // then的链式调用有点繁琐
           // es6有点繁琐
           fetch('https://api.github.com/users/Ming-1213/repos')
           .then(res => res.json())
           .then(data => {
            // console.log(json)
            // document.getElementById('repos').innerHTML = data.map(item => `<li>${item.name}<li>`).join('')
            //   })
            // await 后面通常跟着promise实例
            // new Promise Promise {} fetch本质是返回一个promise实例
            // pending 状态 等待
            console.log(fetch('https://api.github.com/users/Ming-1213/repos'))
            // resolve() fullfilled 完成了
            // reject() rejected 拒绝了
            const result = await fetch('https://api.github.com/users/Ming-1213/repos')
            const data = await result.json()
            // console.log(data)
            document.getElementById('repos').innerHTML = data.map(item => `<li>${item.name}</li>`).join('')
           });
        // api 接口地址
        // www.bilibili.com 网站地址，用户访问的
        // https://api.github.com/users/shunyuwu url
        // JSON 数据返回，这个url对应的是一个资源
        // 有了这个接口之后来到前端，通过fetch主动拉取这个资源，这样，我们就有了动态的web2.0 动态页面
        // 这些接口由后端（node、java、go）写的
        // 前端通过fetch请求接口，拿到数据，渲染到页面上，这样，前端就可以自己做主
    </script>
</body>
</html>